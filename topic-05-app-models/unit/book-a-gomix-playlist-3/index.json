{"type":"lab","chapters":[{"title":"#Objectives","shortTitle":"Lab-6 Playlist 3","contentMd":"#Objectives\n\nEnable Songs and Playlists to be added via simple forms.\n\n"},{"title":"# Exercise Solutions","shortTitle":"Exercise Solutions","contentMd":"# Exercise Solutions\n\nhis lab requires that the `playlist-1` lab be completed. If you have lost your solution, create a new project in Glitch by cloning this repo:\n\n- <https://github.com/wit-hdip-comp-sci-2019/playlist-2>\n\nInstructions on how to do this are [here](https://wit-hdip-comp-sci-2019.github.io/ictskills-1//topic-03-web-apps/unit-2/book-a-glitch-playlist-1/index.html#/01). Remember to use the url above.\n\nThese are the exercises from the last lab:\n\n## Exercise 1: UX Enhancements & Exercise 3: listplaylists partial\n\nIntroduce a 'Delete Playlist' button for each playlist, represented by a `trash` icon.\n\nFirst, create a new partial:\n\n## views/partials/listplaylists.hbs\n\n~~~html\n{{#each playlists}}\n  <section class=\"ui stacked segment\">\n    <h2 class=\"ui header\">\n      {{title}}\n    </h2>\n    <p> Total Duration: {{duration}} </p>\n    <a href=\"/playlist/{{id}}\" class=\"ui icon button\">\n      <i class=\"icon folder open\"></i>\n    </a>\n    <a href=\"/dashboard/deleteplaylist/{{id}}\" class=\"ui icon button\">\n      <i class=\"icon trash\"></i>\n    </a>\n  </section>\n{{/each}}\n~~~\n\nNow we can refactor the dashboard partial to use this:\n\n## views/dashboard.hbs\n\n~~~html\n{{> menu id=\"dashboard\"}}\n\n<section class=\"ui segment\">\n  {{> listplaylists}}\n</section>\n~~~\n\nThe UI should look like this:\n\n![](img/07.png)\n\nHowever, the delete (trash) button doesn't work yet (try it).\n\n## Exercise 2: Delete Playlist Functionality\n\nMake the button actually delete the denoted playlist.\n\nFirst, a route to delete the playlist:\n\n## routes.js\n\n~~~js\n...\nrouter.get('/dashboard/deleteplaylist/:id', dashboard.deletePlaylist);\n...\n~~~\n\nThen the method to implement this route:\n\n## controllers/dashboard.js\n\n~~~js\n...\n  deletePlaylist(request, response) {\n    const playlistId = request.params.id;\n    logger.debug(`Deleting Playlist ${playlistId}`);\n    playlistStore.removePlaylist(playlistId);\n    response.redirect('/dashboard');\n  },\n...\n~~~\n\nWhen introducing the new method above, you will need to separate the method from the existing index method with a comma - an syntax error will appear of you forget this. Here is the complete dashboard.js for reference:\n\n~~~\n\"use strict\";\n\nconst logger = require(\"../utils/logger\");\nconst playlistStore = require(\"../models/playlist-store\");\n\nconst playlist = {\n  index(request, response) {\n    const playlistId = request.params.id;\n    logger.debug(\"Playlist id = \", playlistId);\n    const viewData = {\n      title: \"Playlist\",\n      playlist: playlistStore.getPlaylist(playlistId)\n    };\n    response.render(\"playlist\", viewData);\n  },\n\n  deleteSong(request, response) {\n    const playlistId = request.params.id;\n    const songId = request.params.songid;\n    logger.debug(`Deleting Song ${songId} from Playlist ${playlistId}`);\n    playlistStore.removeSong(playlistId, songId);\n    response.redirect(\"/playlist/\" + playlistId);\n  }\n};\n\nmodule.exports = playlist;\n~~~\n\n\n\nFinally, we need a new method on playlist-store to delete the playlist form the model:\n\n## models/playlist-store.js\n\n~~~js\n  removePlaylist(id) {\n    _.remove(this.playlistCollection, { id: id });\n  },\n~~~\n\nAgain, a comma may be needed. This is the complete playlist-store at this stage:\n\n~~~\n\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst playlistStore = {\n  playlistCollection: require(\"./playlist-store.json\").playlistCollection,\n\n  getAllPlaylists() {\n    return this.playlistCollection;\n  },\n\n  getPlaylist(id) {\n    return _.find(this.playlistCollection, { id: id });\n  },\n\n  removeSong(id, songId) {\n    const playlist = this.getPlaylist(id);\n    _.remove(playlist.songs, { id: songId });\n  },\n  \n  removePlaylist(id) {\n    _.remove(this.playlistCollection, { id: id });\n  },\n};\n\nmodule.exports = playlistStore;\n~~~\n\nVerify now that you can delete playlists.\n\n\n\n"},{"title":"# Adding a Song","shortTitle":"01","contentMd":"# Adding a Song\n\nBefore adding a song, lets align the delete button appearance with the delete playlist. Use this icon button instead of the existing one:\n\n## views/partials/listsongs.hbs\n\n~~~html\n          <a href=\"/playlist/{{../playlist.id}}/deletesong/{{id}}\" class=\"ui icon button\">\n            <i class=\"icon trash\"></i>\n          </a>\n~~~\n\nThis is the complete listsongs partial now:\n\n~~~\n<table class=\"ui table\">\n  <thead>\n    <tr>\n      <th>Song</th>\n      <th>Artist</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    {{#each playlist.songs}}\n      <tr>\n        <td>\n          {{title}}\n        </td>\n        <td>\n          {{artist}}\n        </td>\n        <td>\n          <a href=\"/playlist/{{../playlist.id}}/deletesong/{{id}}\" class=\"ui icon button\">\n            <i class=\"icon trash\"></i>\n          </a>\n        </td>\n      </tr>\n    {{/each}}\n  </tbody>\n</table>\n~~~\n\nIn order to add songs, we need this new partial which provides a simple add song form. Introduce this new partial now:\n\n## views/partials/addsong.hbs\n\n~~~html\n<form class=\"ui stacked segment form\" action=\"/playlist/{{playlist.id}}/addsong\" method=\"POST\">\n  <div class=\"two fields\">\n    <div class=\"field\">\n      <label>Title</label>\n      <input placeholder=\"Title\" type=\"text\" name=\"title\">\n    </div>\n    <div class=\"field\">\n      <label>Artist</label>\n      <input placeholder=\"Artist\" type=\"text\" name=\"artist\">\n    </div>\n  </div>\n  <button class=\"ui blue submit button\">Add Song</button>\n</form>\n~~~\n\nWe need to incorporate this in the playlist view:\n\n## views/playlist.hbs\n\n~~~\n{{> menu}}\n\n<section class=\"ui center aligned middle aligned segment\">\n  <h2 class=\"ui header\">\n    {{playlist.title}}\n  </h2>\n  {{> listsongs}}\n  {{> addsong}}\n</section>\n~~~\n\nThis should now appear at then end of each playlist:\n\n![](img/01.png)\n\nNow we meed a new route to support the form we have just added:\n\n## routes.js\n\n~~~js\n...\nrouter.post('/playlist/:id/addsong', playlist.addSong);\n...\n~~~\n\n... and this new function in the `playlist` controller:\n\n## controllers/playlist.js\n\n~~~js\n...\n  addSong(request, response) {\n    const playlistId = request.params.id;\n    const playlist = playlistStore.getPlaylist(playlistId);\n    const newSong = {\n      title: request.body.title,\n      artist: request.body.artist,\n    };\n    playlistStore.addSong(playlistId, newSong);\n    response.redirect('/playlist/' + playlistId);\n  },\n...\n~~~\n\nThis is the complete playlist controller now:\n\n~~~\n\"use strict\";\n\nconst logger = require(\"../utils/logger\");\nconst playlistStore = require(\"../models/playlist-store\");\n\nconst playlist = {\n  index(request, response) {\n    const playlistId = request.params.id;\n    logger.debug(\"Playlist id = \", playlistId);\n    const viewData = {\n      title: \"Playlist\",\n      playlist: playlistStore.getPlaylist(playlistId)\n    };\n    response.render(\"playlist\", viewData);\n  },\n\n  deleteSong(request, response) {\n    const playlistId = request.params.id;\n    const songId = request.params.songid;\n    logger.debug(`Deleting Song ${songId} from Playlist ${playlistId}`);\n    playlistStore.removeSong(playlistId, songId);\n    response.redirect(\"/playlist/\" + playlistId);\n  },\n  \n  addSong(request, response) {\n    const playlistId = request.params.id;\n    const playlist = playlistStore.getPlaylist(playlistId);\n    const newSong = {\n      title: request.body.title,\n      artist: request.body.artist,\n    };\n    playlistStore.addSong(playlistId, newSong);\n    response.redirect('/playlist/' + playlistId);\n  },\n};\n\nmodule.exports = playlist;\n\n~~~\n\nFinally, we need to implement a new  `addSong` method in the playlist-store:\n\n## modiels/playlist-store.js\n\n~~~js\n  addSong(id, song) {\n    const playlist = this.getPlaylist(id);\n    playlist.songs.push(song);\n  },\n~~~\n\nThis is the complete playlist-store:\n\n~~~\n\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst playlistStore = {\n  playlistCollection: require(\"./playlist-store.json\").playlistCollection,\n\n  getAllPlaylists() {\n    return this.playlistCollection;\n  },\n\n  getPlaylist(id) {\n    return _.find(this.playlistCollection, { id: id });\n  },\n\n  removeSong(id, songId) {\n    const playlist = this.getPlaylist(id);\n    _.remove(playlist.songs, { id: songId });\n  },\n  \n  removePlaylist(id) {\n    _.remove(this.playlistCollection, { id: id });\n  },\n  \n  addSong(id, song) {\n    const playlist = this.getPlaylist(id);\n    playlist.songs.push(song);\n  },\n};\n\nmodule.exports = playlistStore;\n~~~\n\nTry the app  now and verify that you can add songs.\n\nThink about the following at this stage:\n\n- Can you delete one of the songs you have just added? \n- Can you delete one of the songs that have been in there already? \n\nWhat might be happening in the above? (see next step to explore further).\n"},{"title":"# ID Management","shortTitle":"02","contentMd":"# ID Management\n\nDeleting a song you have manually added using the form generates the following:\n\n~~~\nCannot GET /playlist/02/deletesong/\n~~~\n\nHowever, pre-populated songs can still be deleted. What is going on here?\n\nThe issue is that the new songs we have added do not appear to have IDs. Looking at this list for instance:\n\n![](img/02.png)\n\nIn the browser, right-click and select 'view source' and you should see something like this:\n\n![](img/03.png)\n\nLook at the last entry - there is no ID for the new song we added.\n\nHere is our `addsong` function again:\n\n## controlers/playlist.js\n\n~~~js\n  addSong(request, response) {\n    const playlistId = request.params.id;\n    const playlist = playlistStore.getPlaylist(playlistId);\n    const newSong = {\n      title: request.body.title,\n      artist: request.body.artist,\n    };\n    playlistStore.addSong(playlistId, newSong);\n    response.redirect('/playlist/' + playlistId);\n  },\n~~~\n\nThe object we are inserting has only two fields:\n\n~~~js\n    const newSong = {\n      title: request.body.title,\n      artist: request.body.artist,\n    };\n~~~\n\nWe need to also insert a new, unique, ID for each object we create.\n\nHow do we create a new ID? This can be challenged in implement manually. However, one solution is to use Universally Unique Identifiers:\n\n- <https://en.wikipedia.org/wiki/Universally_unique_identifier>\n\nA library to generate a uuid is already in our app, we just need to import and use it\n\nAt the top of the `playlist` controller, we require the library. Insert this at the top of the modile:\n\n## controllers/playlists.js\n~~~\nconst uuid = require('uuid');\n~~~\n\nNow, when we are creating a playlist, we can use the library to generate a unique id for us:\n\n~~~js\n  const newSong = {\n    id: uuid(),\n    title: request.body.title,\n    artist: request.body.artist,\n  };\n~~~\n\nThis is the complete playlist module at this stage:\n\n~~~\n\"use strict\";\n\nconst logger = require(\"../utils/logger\");\nconst playlistStore = require(\"../models/playlist-store\");\nconst uuid = require('uuid');\n\nconst playlist = {\n  index(request, response) {\n    const playlistId = request.params.id;\n    logger.debug(\"Playlist id = \", playlistId);\n    const viewData = {\n      title: \"Playlist\",\n      playlist: playlistStore.getPlaylist(playlistId)\n    };\n    response.render(\"playlist\", viewData);\n  },\n\n  deleteSong(request, response) {\n    const playlistId = request.params.id;\n    const songId = request.params.songid;\n    logger.debug(`Deleting Song ${songId} from Playlist ${playlistId}`);\n    playlistStore.removeSong(playlistId, songId);\n    response.redirect(\"/playlist/\" + playlistId);\n  },\n  \n  addSong(request, response) {\n    const playlistId = request.params.id;\n    const playlist = playlistStore.getPlaylist(playlistId);\n    const newSong = {\n      id: uuid(),\n      title: request.body.title,\n      artist: request.body.artist,\n    };\n    playlistStore.addSong(playlistId, newSong);\n    response.redirect('/playlist/' + playlistId);\n  },\n};\n\nmodule.exports = playlist;\n~~~\n\nTry this now and make sure the new songs can be deleted. View the source to reveal the uuid-style ids in the new songs:\n\n![](img/08.png)\n\nIn addition, we can add a log statement so that we can see the songs as they are added:\n\n~~~\n...\n    logger.debug('New Song = ', newSong);\n...\n~~~\n"},{"title":"# Adding playlists","shortTitle":"03","contentMd":"# Adding playlists\n\nTaking the last step as an example, we can quickly implement the necessary form, route, controller function and model update to support adding a new playlist (as opposed to a song).\n\nThis is a new addplaylist partial:\n\n## views/partials/addplaylist.hbs\n\n~~~html\n<form class=\"ui stacked segment form\" action=\"/dashboard/addplaylist\" method=\"POST\">\n  <div class=\"field\">\n    <label>Title</label>\n    <input placeholder=\"Title\" type=\"text\" name=\"title\">\n  </div>\n  <button class=\"ui blue submit button\">Add Playlist</button>\n</form>\n~~~\n\nModify dashboard to append this partial:\n\n## views/dashboard.hbs\n\n~~~html\n{{> menu id=\"dashboard\"}}\n\n<section class=\"ui segment\">\n  {{> listplaylists}}\n  {{> addplaylist}}\n</section>\n~~~\n\nThis now requires a new route:\n\n## routes.js\n\n~~~js\nrouter.post('/dashboard/addplaylist', dashboard.addPlaylist);\n~~~\n\n.. and this is the new method on the dashboard controller:\n\n## controllers/dashboard.js\n\nImport the uuid library at the top:\n\n~~~js\nconst uuid = require('uuid');\n~~~\n\n... and then this new method\"\n\n~~~\n...\n  addPlaylist(request, response) {\n    const newPlayList = {\n      id: uuid(),\n      title: request.body.title,\n      songs: [],\n    };\n    playlistStore.addPlaylist(newPlayList);\n    response.redirect('/dashboard');\n  },\n~~~\n\nNotice we are again using the uuid library here to generate and ID for the new playlist.\n\nFinally, a new method in the playlist-store to add a playlist:\n\n## modes/playlist-store.js\n\n~~~js\naddPlaylist(playlist) {\n  this.playlistCollection.push(playlist);\n},\n~~~\n\nWe should now be able to add new playlists.\n"},{"title":"# Persistence","shortTitle":"04","contentMd":"# Persistence\n\nYou will note that, even though we are able to add/delete playlists/songs, every time the app restarts then we are left with the same initial playlist. i.e. none of the changes we make are `persisted` beyond the life of the program execution.\n\nThis is the field of databases - and beyond the scope of this course for the moment. However, we can implement something like a database, but simpler, which can serve our needs. Introduce this new class into the project:\n\n## models/json-store.js\n\n~~~js\n'use strict';\n\nconst low = require('lowdb');\nconst FileSync = require('lowdb/adapters/FileSync')\n\nclass JsonStore {\n  constructor(file, defaults) {\n    const adapter = new FileSync(file)\n    this.db = low(adapter)\n    this.db.defaults(defaults).value();\n  }\n\n  save() {\n    this.db.write();\n  }\n\n  add(collection, obj) {\n    this.db.get(collection).push(obj).last().value();\n  }\n\n  remove(collection, obj) {\n    this.db.get(collection).remove(obj).value();\n  }\n\n  removeAll(collection) {\n    this.db.get(collection).remove().value();\n  }\n\n  findAll(collection) {\n    return this.db.get(collection).value();\n  }\n\n  findOneBy(collection, filter) {\n    const results = this.db.get(collection).filter(filter).value();\n    return results[0];\n  }\n\n  findByIds(collection, ids) {\n    return this.db.get(collection).keyBy('id').at(ids).value();\n  }\n\n  findBy(collection, filter) {\n    return this.db.get(collection).filter(filter).value();\n  }\n}\n\nmodule.exports = JsonStore;\n~~~\n\nThis is a wrapper around this module:\n\n- <https://github.com/typicode/lowdb>\n\nIt will manage the json file we have been using, enabling updates in a convenient manner. You do not need to understand this module in depth for the moment, we will use another wrapper module to interact with it.\n\nHere is the wraper, which is a new version of our playlist store module:\n\n## models/playlist-store.js\n\n~~~js\n'use strict';\n\nconst _ = require('lodash');\nconst JsonStore = require('./json-store');\n\nconst playlistStore = {\n\n  store: new JsonStore('./models/playlist-store.json', { playlistCollection: [] }),\n  collection: 'playlistCollection',\n\n  getAllPlaylists() {\n    return this.store.findAll(this.collection);\n  },\n\n  getPlaylist(id) {\n    return this.store.findOneBy(this.collection, { id: id });\n  },\n\n  addPlaylist(playlist) {\n    this.store.add(this.collection, playlist);\n    this.store.save();\n  },\n\n  removePlaylist(id) {\n    const playlist = this.getPlaylist(id);\n    this.store.remove(this.collection, playlist);\n    this.store.save();\n  },\n\n  removeAllPlaylists() {\n    this.store.removeAll(this.collection);\n    this.store.save();\n  },\n\n  addSong(id, song) {\n    const playlist = this.getPlaylist(id);\n    playlist.songs.push(song);\n    this.store.save();\n  },\n\n  removeSong(id, songId) {\n    const playlist = this.getPlaylist(id);\n    const songs = playlist.songs;\n    _.remove(songs, { id: songId});\n    this.store.save();\n  },\n};\n\nmodule.exports = playlistStore;\n~~~\n\nNo other changes are necessary - as all access to the playlist is via the above module.\n\nThe app should work now as before, except this time changes to the playlists will be `persisted` to the json file. This means that if the app has to be restarted, it will have preserved any changes to the playlist in the JSON file, which will be reloaded when the app restarts.\n\nYou can force a reload by deliberately introducing a syntax error - and then correcting it.\n\nHowever, because of limitations in the way glitch is currently configured the playlist-store.json file will often not be in sync and not be updated at all. If you download and run the application locally (in webstorm), the json file will be updated accurately.\n\n\n\n"},{"title":"# Exercises","shortTitle":"Exercises","contentMd":"# Exercises\n\nIf you want to download a complete version of the app as it should be at the end of this lab, then create a new Glitch project, and clone this repo:\n\n- <https://github.com/wit-hdip-comp-sci-2019/playlist-3>\n\nYou can also clone this repo directly, run 'npm install' from inside the folder and then run from within Webstorm.\n\n## Exercise 1: Display Durations\n\nMake sure the duration of each song and playlist is visible on the UX\n\n![](img/04.png)\n![](img/05.png)\n\n## Exercise 2: Add Song Duration\n\nModify the add song form to accept a song duration as well as title and artist:\n\n![](img/06.png)\n\nMake sure the duration is stored in the data store, and is displayed on the playlist view.\n\nHINT: When reading a parameter from a form representing a number, you will need to convert it from string. The `Number` function is one simple way of doing this:\n\n~~~\n    const newSong = {\n      id: uuid(),\n      title: request.body.title,\n      artist: request.body.artist,\n      duration: Number(request.body.duration),\n    };\n~~~\n\n## Exercise 3: Active Duration\n\nThe durations in each playlist are just constants stored in the database. Currently, if you add a new playlist + songs, then the duration in the playlist will be undefined.\n\nChange this now, such that when you add a song to a playlist the duration displayed on the dashboard for each playlist will be the actual sum of the donations for all songs in the playlist.\n\nHINT: One way of dong this is to update the `addSong()` method in the `playlist-store` object:\n\n~~~\n  addSong(id, song) {\n    const playlist = this.getPlaylist(id);\n    playlist.songs.push(song);\n\n    let duration = 0;\n    // Iterate over the playlist.songs array, and accumulate the duration of each\n    // song into the duration local variable.\n    // ...\n    // ...\n\n    // Now store the duration in playlist.store\n    // ...\n    \n    this.store.save();\n  },\n~~~"}]}